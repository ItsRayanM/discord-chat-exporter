import {
  AttachmentBuilder,
  ChannelType,
  type AnySelectMenuInteraction,
  type ButtonInteraction,
} from "discord.js";
import { createExporter } from "@/core/exporter.js";
import type { AdvancedTicketCloseHandlerOptions, ExportRequest } from "@/types.js";

type SupportedInteraction = ButtonInteraction | AnySelectMenuInteraction;

export function createAdvancedTicketCloseHandler(options: AdvancedTicketCloseHandlerOptions) {
  const exporter = createExporter();

  return async (interaction: SupportedInteraction): Promise<void> => {
    if (!interaction.isRepliable()) {
      return;
    }

    const channel = interaction.channel;
    if (!channel || !("id" in channel)) {
      await interaction.reply({
        ephemeral: true,
        content: "Could not resolve ticket channel.",
      });
      return;
    }

    await interaction.deferReply({ ephemeral: true });

    const dynamicRequest = options.exportRequestFactory?.(channel.id) ?? {};

    const exportRequest: ExportRequest = {
      token: dynamicRequest.token ?? options.token,
      guildId: dynamicRequest.guildId,
      channelId: channel.id,
      threadIds: dynamicRequest.threadIds,
      formats: dynamicRequest.formats ?? options.formats ?? ["html-single", "json-full"],
      filters: dynamicRequest.filters,
      predicate: dynamicRequest.predicate,
      attachments: dynamicRequest.attachments,
      render: dynamicRequest.render,
      output: {
        dir: options.outputDir ?? "./exports",
        ...(dynamicRequest.output ?? {}),
      },
      recorder: dynamicRequest.recorder,
      analytics: dynamicRequest.analytics,
      filterContext: dynamicRequest.filterContext,
      redaction: dynamicRequest.redaction,
      delta: dynamicRequest.delta,
      compliance: dynamicRequest.compliance,
      monitoring: dynamicRequest.monitoring,
    };

    const result = await exporter.exportChannel(exportRequest);

    const logChannel = await interaction.client.channels.fetch(options.logChannelId);
    if (logChannel && logChannel.isTextBased() && "send" in logChannel) {
      const files = result.files.map(
        (artifact) =>
          new AttachmentBuilder(artifact.path, {
            name: artifact.path.split(/[\\/]/).pop(),
          }),
      );

      await logChannel.send({
        content: `Ticket transcript for <#${channel.id}> generated by ${interaction.user.tag}`,
        files,
      });
    }

    if (options.postActions?.notifyUserDm) {
      try {
        await interaction.user.send(
          `Your ticket transcript has been exported successfully. Channel: ${channel.id}`,
        );
      } catch {
        // DM can fail when user blocks DMs.
      }
    }

    const shouldArchive = options.postActions?.archiveThread ?? options.archiveThread;
    if (shouldArchive && channel.type === ChannelType.PrivateThread) {
      await channel.setArchived(true, options.closeReason);
    }

    if (options.postActions?.deleteChannel) {
      try {
        if ("deletable" in channel && channel.deletable) {
          await channel.delete(options.closeReason);
        }
      } catch {
        // Ignore deletion failures and still return export success.
      }
    }

    await interaction.editReply({
      content: `Transcript exported successfully (${result.files.length} files).`,
    });
  };
}
