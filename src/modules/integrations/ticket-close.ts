import { AttachmentBuilder, ChannelType, type AnySelectMenuInteraction, type ButtonInteraction } from "discord.js";
import type { TicketCloseHandlerOptions } from "@/types.js";
import { createExporter } from "@/core/exporter.js";

type SupportedInteraction = ButtonInteraction | AnySelectMenuInteraction;

export function createTicketCloseHandler(options: TicketCloseHandlerOptions) {
  const exporter = createExporter();

  return async (interaction: SupportedInteraction): Promise<void> => {
    if (!interaction.isRepliable()) {
      return;
    }

    const channel = interaction.channel;
    if (!channel || !("id" in channel)) {
      await interaction.reply({
        ephemeral: true,
        content: "Could not resolve ticket channel.",
      });
      return;
    }

    await interaction.deferReply({ ephemeral: true });

    const result = await exporter.exportChannel({
      token: options.token,
      channelId: channel.id,
      formats: options.formats ?? ["html-single", "json-full"],
      output: {
        dir: options.outputDir ?? "./exports",
      },
    });

    const logChannel = await interaction.client.channels.fetch(options.logChannelId);

    if (logChannel && logChannel.isTextBased() && "send" in logChannel) {
      const files = result.files.map(
        (artifact) => new AttachmentBuilder(artifact.path, { name: artifact.path.split(/[\\/]/).pop() }),
      );

      await logChannel.send({
        content: `Ticket transcript for <#${channel.id}> generated by ${interaction.user.tag}`,
        files,
      });
    }

    if (options.archiveThread && channel.type === ChannelType.PrivateThread) {
      await channel.setArchived(true, options.closeReason);
    }

    await interaction.editReply({
      content: `Transcript exported successfully (${result.files.length} files).`,
    });
  };
}
